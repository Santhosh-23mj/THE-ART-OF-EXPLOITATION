#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "hacking.h"
#include "network-hacking.h"

#define PORT 80
#define WEBROOT "./webroot"

void handle_connections(  int, struct sockaddr_in * );  // Handle Web Requests
int get_file_size(int);                                // Return file size

int main(void)
{
    int sockfd, new_sockfd, yes = 1;
    struct sockaddr_in host_addr, client_addr;    // Address information
    socklen_t sin_size;

    printf("Accepting Web requests on port %d\n",PORT);

    if ( (sockfd = socket( PF_INET, SOCK_STREAM, 0 )) == -1 )
        prnerr("in socket");

    if ( setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int) ) == -1 )
        prnerr("while setting socket SO_REUSEADDR");

    host_addr.sin_family = AF_INET;     // host byte order
    host_addr.sin_port = htons(PORT);   // short n/w byte order
    host_addr.sin_addr.s_addr = INADDR_ANY;   // Automatically fill my IP
    memset(&(host_addr.sin_zero),'\0',8);

    if ( (bind( sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr))) == -1 )
        prnerr("binding to socket");

    if ( (listen( sockfd, 20 )) == -1 )
        prnerr("while listening on socket");

    while (1)
    {
        sin_size = sizeof(struct sockaddr_in);
        new_sockfd = accept( sockfd, (struct sockaddr *)&client_addr, &sin_size );
        if ( new_sockfd == -1 )
            prnerr("while accepting connection");
        handle_connection( new_sockfd, &client_addr);
    }

    return 0;
}

/* This function handles connection on passed socked FD on passed
 * client address. This process as a web request to serve the
 * webpage and finally closes the socket connection
 */

void handle_connection( int sockfd, struct sockaddr_in *client_addr_ptr )
{
    unsigned char *ptr, request[500], resource[500];
    int fd,length;

    length = recv_line( sockfd, request );

    printf("Got REQUEST from %s:%d \\%s\\ \n", inet_ntoa(client_addr_ptr->sin_addr),ntohs(client_addr_ptr->sin_port),request);

    ptr = strstr( request, " HTTP/");

    if ( ptr == NULL )
    {
        printf("Not HTTP !!\n");
    }
    else
    {
        *ptr = 0;
        ptr = NULL;

        if ( (strncmp(request,"GET ",4)) == 0 )
            ptr = request + 4;
        if ( (strncmp(request,"HEAD ",5)) == 0 )
            ptr = request + 5;
        if ( ptr == NULL )
            printf("\tUNKNOWN REQUEST\n");
        else
        {
            if ( ptr[strlen(ptr)-1] == '/' )
                strcat(ptr,"index.html");
            strcpy(resource,WEBROOT);
            strcat(resource,ptr);
            fd = open( resource, O_RDONLY, 0 );
            printf("\tOpening \\%s\\\t",resource);
            if ( fd == -1 )
            {
                printf(" 404 Not Found !\n");
                send_string( sockfd, "HTTP/1.0 404 Not Found !\r\n");
                send_string( sockfd, "Server: Tiny WebServer\r\n\r\n");
                send_string( sockfd, "<html><head><titile>404 Not Found !</title></head>");
                send_string( sockfd, "<body><h1>URL Not Found... :(</body></html>\r\n");
            }
            else
            {
                printf("  200 OK\n");
                send_string( sockfd, "HTTP/1.0 200 OK\r\n");
                send_string( sockfd, "Server: Tiny WebServer\r\n\r\n");
                if ( ptr == (request + 4) )
                {
                    if ( (length = get_file_size(fd)) == -1 )
                        prnerr("getting resource file size");
                    if ( (ptr = (unsigned char *) malloc(length)) == NULL )
                        prnerr("allocating memory for reading resource");
                    read( fd, ptr, length );
                    send( sockfd, ptr, length, 0 );
                    free(ptr);
                }

                close(fd);
            }
        }
    }
    shutdown( sockfd, SHUT_RDWR );
}

/* This Function accepts open file descriptor and returns
 * size of allocated file and -1 if failed
 */

int get_file_size(int fd)
{
    struct stat stat_struct;

    if ( (fstat( fd, &stat_struct )) == -1 )
        return -1;
    return (int) stat_struct.st_size;
}