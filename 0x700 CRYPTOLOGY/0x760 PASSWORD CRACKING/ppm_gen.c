/*
 * This is a PoC by Jon Erickson
 * To generate a password probability matrix
 * which reduces the time to crack a hash
 * This is done for 4 character passwords salted with
 * 'sk'
 */

#define _XOPEN_SOURCE
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

#define HEIGHT 16384
#define WIDTH  1129
#define DEPTH  8
#define SIZE   HEIGHT*WIDTH*DEPTH

// Map a single hash byte to enumerated value
int enum_hashbyte(char a)
{
    int i,j;

    i = (int)a;
    if((i >= 46) && (i <= 57))
        j = i - 46;
    else if((i >= 65) && (i <= 90))
        j = i - 53;
    else if((i >= 97)&&(i <= 122))
        j = i -59;
    return j;
}

//Map 3 hash bytes to enumerated value
int enum_hashtriplet( char a, char b, char c )
{
    return (((enum_hashbyte(c)%4)*4096) + (enum_hashbyte(a)*64) + enum_hashbyte(b));
}

//Barf a message and exit
void barf(char *message, char *extra)
{
    printf(message,extra);
    exit(1);
}

//Generate 4-char.ppm file with all possible passwords(4 chars) salt 'sk'
int main()
{
    char plain[5];
    char *code,*data;
    int i,j,k,l;
    unsigned int charval, val;
    FILE *handle;

    if(!(handle = fopen("4char.ppm","w")))
        barf("Error : Couldnt open file 4char.ppm for writing.\n",NULL);

    data = (char *)malloc(SIZE);
    if(!(data))
        barf("Error : Couldnt allocate memory.\n");

    for( i = 32; i < 127; i++)
    {
        for( j = 32; j < 127; j++)
        {
            printf("Adding %c%c to 4char.ppm....\n",i,j);
            for( k = 32; k < 127; k++)
            {
                for( l = 32; l < 127; l++)
                {
                    plain[0] = (char)i;
                    plain[1] = (char)j;
                    plain[2] = (char)k;
                    plain[3] = (char)l;
                    plain[4] = '\0';

                    code = crypt((const char *)plain,(const char *)"sk");

                    //losefully store statistical info about pairs
                    val = enum_hashtriplet( code[2], code[3], code[4] );

                    charval = (i-32)*95 + (j-32);
                    data[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));
                    val += (HEIGHT*4);
                    charval = (k-32)*95 + (l-32);
                    data[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));

                    val = HEIGHT + enum_hashtriplet(code[4], code[5], code[6]);

                    charval = (i-32)*95 + (j-32);
                    data[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));
                    val += (HEIGHT*4);
                    charval = (k-32)*95 + (l-32);
                    data[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));

                    val = (2*HEIGHT) + enum_hashtriplet(code[6], code[7], code[8]);

                    charval = (i-32)*95 + (j-32);
                    data[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));
                    val += (HEIGHT*4);
                    charval = (k-32)*95 + (l-32);
                    data[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));

                    val = (3*HEIGHT) + enum_hashtriplet(code[8], code[9], code[10]);

                    charval = (i-32)*95 + (j-32);
                    data[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));
                    val += (HEIGHT*4);
                    charval = (k-32)*95 + (l-32);
                    data[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));
                }
            }
        }
    }

    printf("finished... saving.. \n");
    fwrite(data, SIZE, 1, handle);
    free(data);
    fclose(handle);
}