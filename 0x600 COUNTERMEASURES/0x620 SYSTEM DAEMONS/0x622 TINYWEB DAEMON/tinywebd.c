#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <time.h>
#include <signal.h>

#include "hacking.h"
#include "network-hacking.h"

#define PORT 80
#define WEBROOT "./webroot"
#define LOGFILE "/var/log/tinywebd.log"

int logfd,sockfd;
void handle_connections(  int, struct sockaddr_in *, int );  // Handle Web Requests
int get_file_size(int);                                // Return file size
void timestamp( int );

/*
 * This function shuts down the Daemon
 * without any problems. It closes the socket and the
 * fd for log file
 */
void handle_shutdown( int signal )
{
    timestamp(logfd);
    write( logfd, "Shutting down.\n", 16 );
    close(logfd);
    close(sockfd);
    exit(0);
}

int main(void)
{
    int new_sockfd, yes = 1;
    struct sockaddr_in host_addr, client_addr;    // Address information
    socklen_t sin_size;

    printf("Accepting Web requests on port %d\n",PORT);

    // Opening log file
    logfd = open(LOGFILE,O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IRGRP );
    if ( logfd == -1 )
        prnerr("opening the logfile");

    if ( (sockfd = socket( PF_INET, SOCK_STREAM, 0 )) == -1 )
        prnerr("in socket");

    if ( setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int) ) == -1 )
        prnerr("while setting socket SO_REUSEADDR");

    // Forking a process
    printf("Starting web Daemon.\n");
    if ( daemon(1,0) == -1 )
        prnerr("while forking daemon to process");

    // Handling shutdown
    signal(SIGTERM,handle_shutdown);
    signal(SIGINT,handle_shutdown);

    timestamp(logfd);
    write(logfd,"Starting up.\n",15);
    host_addr.sin_family = AF_INET;     // host byte order
    host_addr.sin_port = htons(PORT);   // short n/w byte order
    host_addr.sin_addr.s_addr = INADDR_ANY;   // Automatically fill my IP
    memset(&(host_addr.sin_zero),'\0',8);

    if ( (bind( sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr))) == -1 )
        prnerr("binding to socket");

    if ( (listen( sockfd, 20 )) == -1 )
        prnerr("while listening on socket");

    while (1)
    {
        sin_size = sizeof(struct sockaddr_in);
        new_sockfd = accept( sockfd, (struct sockaddr *)&client_addr, &sin_size );
        if ( new_sockfd == -1 )
            prnerr("while accepting connection");
        handle_connection( new_sockfd, &client_addr, logfd);
    }

    return 0;
}

/* This function handles connection on passed socked FD on passed
 * client address. This process as a web request to serve the
 * webpage and finally closes the socket connection
 * Now also logs the connection details to a logfile
 */

void handle_connection( int sockfd, struct sockaddr_in *client_addr_ptr, int logfd )
{
    unsigned char *ptr, request[500], resource[500], logbuffer[500];
    int fd,length;

    length = recv_line( sockfd, request );

    sprintf( logbuffer,"Got REQUEST from %s:%d \\%s\\ \n", inet_ntoa(client_addr_ptr->sin_addr),ntohs(client_addr_ptr->sin_port),request);

    ptr = strstr( request, " HTTP/");

    if ( ptr == NULL )
    {
        printf("Not HTTP !!\n");
    }
    else
    {
        *ptr = 0;
        ptr = NULL;

        if ( (strncmp(request,"GET ",4)) == 0 )
            ptr = request + 4;
        if ( (strncmp(request,"HEAD ",5)) == 0 )
            ptr = request + 5;
        if ( ptr == NULL )
            printf("\tUNKNOWN REQUEST\n");
        else
        {
            if ( ptr[strlen(ptr)-1] == '/' )
                strcat(ptr,"index.html");
            strcpy(resource,WEBROOT);
            strcat(resource,ptr);
            fd = open( resource, O_RDONLY, 0 );
            printf("\tOpening \\%s\\\t",resource);
            if ( fd == -1 )
            {
                strcat( logbuffer," 404 Not Found !\n");
                send_string( sockfd, "HTTP/1.0 404 Not Found !\r\n");
                send_string( sockfd, "Server: Tiny WebServer\r\n\r\n");
                send_string( sockfd, "<html><head><titile>404 Not Found !</title></head>");
                send_string( sockfd, "<body><h1>URL Not Found... :(</body></html>\r\n");
            }
            else
            {
                strcat( logbuffer,"  200 OK\n");
                send_string( sockfd, "HTTP/1.0 200 OK\r\n");
                send_string( sockfd, "Server: Tiny WebServer\r\n\r\n");
                if ( ptr == (request + 4) )
                {
                    if ( (length = get_file_size(fd)) == -1 )
                        prnerr("getting resource file size");
                    if ( (ptr = (unsigned char *) malloc(length)) == NULL )
                        prnerr("allocating memory for reading resource");
                    read( fd, ptr, length );
                    send( sockfd, ptr, length, 0 );
                    free(ptr);
                }

                close(fd);
            }
        }
    }

    timestamp(logfd);
    length = strlen(logbuffer);
    write( logfd, logbuffer, length );

    shutdown( sockfd, SHUT_RDWR );
}

/* This Function accepts open file descriptor and returns
 * size of allocated file and -1 if failed
 */

int get_file_size(int fd)
{
    struct stat stat_struct;

    if ( (fstat( fd, &stat_struct )) == -1 )
        return -1;
    return (int) stat_struct.st_size;
}

/*
 * A fuction to write timestamp to the
 * passed logfd
 */

void timestamp( int logfd )
{
    time_t now;
    struct tm *time_struct;
    int length;
    char time_buffer[40];

    time(&now);
    time_struct = localtime((const time_t *)&now);
    length = strftime(time_buffer,40,"%m/%d/%Y %H:%M:%S>",time_struct);
    write( logfd, time_buffer, length );
}
