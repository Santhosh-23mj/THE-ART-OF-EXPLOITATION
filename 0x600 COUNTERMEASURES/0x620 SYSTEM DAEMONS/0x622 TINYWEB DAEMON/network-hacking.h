/* This function accepts two args one Socket FD and
 * the pointer to null terminated string to send
 * It ensures all bytes are sent and returns 1 if successful
 * else returns 0
 */

int send_string( int sockfd, unsigned char *buffer )
{
    int sent_bytes, bytes_to_send;

    bytes_to_send = strlen(buffer);

    while ( bytes_to_send > 0 )
    {
        sent_bytes = send( sockfd, buffer, bytes_to_send, 0 );    // Sending the bytes
        if ( sent_bytes == -1 )                                   // Error in sending
            return 0;                                             // Return error
        bytes_to_send -= sent_bytes;                              // to send remaining bytes
        buffer += sent_bytes;                                     // decrease buffer to next send
    }

    return 1;                                                     // return success
}

/* This functions accepts Socket FD and destination buffer
 * to write the data. It reads EOL bytes but terminates before that.
 * It returns the length of the readline excluding the
 * EOL characters
 */

int recv_line( int sockfd, unsigned char *dest_buffer )
{
    #define EOL "\r\n"      //End-Of-Line bytes and their size
    #define EOL_SIZE 2

    unsigned char *ptr;
    int eol_match = 0;

    ptr = dest_buffer;

    while ( (recv( sockfd, ptr, 1, 0 )) == 1 )         // Read a Single byte
    {
        if ( *ptr == EOL[eol_match] )                 // Does current byte match EOL bytes
        {
            eol_match++;
            if ( eol_match == EOL_SIZE )              // If all bytes match terminator
            {
                *( ptr+1-EOL_SIZE ) = '\0';           // Terminate the string
                return strlen(dest_buffer);           // Return the length of the string
            }
        }
        else
        {
            eol_match = 0;
        }

        ptr++;                                       // Increment to next byte
    }

    return 0;                                       // Return terminator not found
}